#### 2022-04-05 : страница 27
#### 2022-04-06 : страница 43 Глава 3: Основные типы данных

c++ типы данных 

1. символьный,
2. символьный двубайтовый,
3. целочисленный,
4. с плавающей точкой,
5. с плавающей точкой двойной точности,
6. логический (или булев),
7. "не имеющий значения".

char, wchar_t, int, float, double, bool и void

Модификаторы типов, для char , int, double

signed 
unsigned 
long
short

#### 2022-04-07 : страница 53 Глава 3: Основные типы данных

Операторы:

Арифмитические 
********************

+ - * / 
% деление по модулю - остаток от деления
-- декремент
++ инкремент

Логические 
********************

&&  || !

Приведене типов

(float) х / 2

cout << i << "/ 2 равно: " << (float) i / 2 << '\n';


#### 2022-04-07 : страница 68 Глава 4: Инструкции управления Your Progress c++ 8.60759 %



for(x=0, у=10; х<=10; ++х, --у)
cout << х << ' ' << у << '\n';
Здесь запятыми отделяются две инструкции инициализации и два инкрементных
выражения. Это делается для того, чтобы компилятор "понимал", что существует две
инструкции инициализации и две инструкции инкремента (декремента). В C++ запятая
представляет собой оператор, который, по сути, означает "сделай это и то".



#### 2022-04-08 : страница 99 Глава 4: Глава 5: Массивы и строки Your Progress c++ 12.5316 %


### Одномерный массив тип имя_массива [размер];


Для одномерных массивов общий размер массива в байтах вычисляется так:
всего байтов = размер типа в байтах х количество элементов.


Сортировка массива

Строка — это символьный массив, который завершается нулевым символом.

При определении длины символьного массива необходимо учитывать признак ее
завершения и задавать его длину на единицу больше длины самой большой строки из тех,
которые предполагается хранить в этом массиве.

#### Строковый литерал — это список символов, заключенный в двойные кавычки.
 
"Привет Мир"

Функция strcpy() копирует содержимое строки from в строку to.
Функция strcat() присоединяет строку s2 к концу строки s1,
Функция strcmp() сравнивает строку s2 со строкой s1 и возвращает значение 0, если они
равны.
Функция strlen() возвращает длину строки,



### Двумерные массивы

int twod[10][20];

один индекс означает строку, а второй — столбец

число байтов = число строк х число столбцов х размер типа в байтах

### Многомерные массивы

int multidim[4][10][3];

#### Инициализация массивов

тип имя_массива [размер] = {список_значений};

int i [ 10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
char str [7] = {'п', 'р', 'и', 'в', 'е', 'т', '\0'};
char str[7] = "привет";

### "Безразмерная" инициализация массивов


C++ предусмотрена
возможность автоматического определения длины массивов путем использования их
"безразмерного" формата. Если в инструкции инициализации массива не указан его размер,
C++ автоматически создаст массив, размер которого будет достаточным для хранения всех
значений инициализаторов.

char е1[] = "Деление на 0\n";
char е2[] = "Конец файла\n";
char еЗ[] = "В доступе отказано\n";

### Массивы строк

char str_array[30][80];
Массив строк — это специальная форма двумерного массива символов.




#### 2022-04-09 : страница 132 Глава 6: Указатели Your Progress c++ 16.7089 %

Указатель — это переменная, которая содержит адрес другой переменной

```c++
тип *имя_переменной;
int *р;
```


Операторы, используемые с указателями

Оператор "&" — унарный. Он возвращает адрес памяти, по которому расположен его операнд.

```c++
balptr = &balance;  // Получить адресс 
value = *balptr;    // Получить значение 
```

Присваивание значений с помощью указателей

```c++
*р = 101; // можно прочитать так: "по адресу р помещаем значение 101".


(*р)++; // 102


// Арифмитические операции с указателями ++ -- - +
```

в C++
использование имени массива без индекса генерирует указатель на первый элемент этого
массива. Таким образом, при выполнении присваивания p1 = str адрес stг[0] присваивается
указателю p1.

Индексирование указателя


#### 2022-04-10 : страница 145 Глава 6: Указатели Your Progress c++ 18.3544 %

```c++
float *р = 0; // р — теперь нулевой указатель

if(р) // Выполняем что-то, если р — не нулевой указатель.
if(!p) // Выполняем что-то, если р — нулевой указатель.
Соблюдая упомянутое выше соглашение о нулевых указателях, вы можете избежать
многих серьезных проблем, возникающих при использование указателей.
```

### Многоуровневая непрямая адресация

```c++
int **balance;


```

#### 2022-04-12 : Страница 161 Глава 7:Функции, часть первая: ОСНОВЫ Your Progress c++ 20.3797 %

ключевое слово auto, которое можно использовать для объявления
локальных переменных.

### Вызов функций с указателями

В C++ разрешается передавать функции указатели. Для этого достаточно объявить
параметр типа указатель. Рассмотрим пример.



### Вызов функций с массивами

Если массив является аргументом функции, то необходимо понимать, что при вызоветакой функции ей передается только адрес первого элемента массива, а не полная его
копия. (Помните, что в C++ имя массива без индекса представляет собой указатель на
первый элемент этого массива.) Это означает, что объявление параметра должно иметь тип,
совместимый с типом аргумента.


1. Во-первых, параметр можно объявить как массив,
тип и размер которого совпадает с типом и размером массива, используемого при вызове
функции. Этот вариант объявления параметра-массива продемонстрирован в следующем
примере.

```c++
void display(int num[10])
```

2. Второй способ объявления параметра-массива состоит в его представлении в виде
безразмерного массива, как показано ниже.

```c++
void display(int num[])
```

3. При передаче
массива функции ее параметр можно объявить как указатель. Как раз этот вариант чаще
всего используется профессиональными программистами.

```c++
void display(int *num)
```

#### 2022-04-13 : Страница 177 Глава 7:Функции, часть первая: ОСНОВЫ Your Progress c++ 22.4051 %


Передача функциям строк
Как вы уже знаете, строки в C++ — это обычные символьные массивы, которые
завершаются нулевым символом. Таким образом, при передаче функции строки реально
передается только указатель (типа char*) на начало этой строки. Рассмотрим, например,
следующую программу.


Аргументы функции main(): argc и argv

Параметр argc имеет целочисленный тип и предназначен для хранения количества
аргументов командной строки. Его значение всегда не меньше единицы, поскольку имя
программы также является одним из учитываемых аргументов. Параметр argv представляет
собой указатель на массив символьных указателей. Каждый указатель в массиве argvссылается на строку, содержащую аргумент командной строки. Элемент argv[0] указывает
на имя программы; элемент argv[1] — на первый аргумент, элемент argv[2] — на второй и
т.д.


```c++

char *argv[];

#include <iostream>
using namespace std;
int main(int argc, char *argv[])
{
if(argc!=2) {
cout << "Вы забыли ввести свое имя.\n";
return 1;
}
cout << "Привет, " << argv[1] << '\n';
return 0;
}

```

Преобразование числовых строк в числа

atoi(), atol() и atof().



#### 2022-04-16 : Страница 177 Глава 7:Функции, часть первая: ОСНОВЫ Your Progress c++ 24.1772 %


Функции, которые возвращают указатели


```c++

Вот как, например, объявляется тип возвращаемого значения для
функции f(), которая должна возвращать указатель на целое число.

int *f();


```

Прототип функции


```c++

/* В этой программе используется прототип
позволяет осуществить строгий контроль типов.
функции,
который
*/
void sqr_it(int *i); // прототип функции
int main()
{
int х;
х = 10;
sqr_it(x); // *** Ошибка *** — несоответствие типов!
return 0;
}
void sqr_it(int *i)
{
*i=*i * *i;
}
```


#### 2022-04-17 : Глава 8: Функции, часть вторая: ссылки, перегрузка и использование аргументов по умолчанию Your Progress c++ 25.443 %


Два способа передачи аргументов
- При вызове по значению функции передается значение аргумента. call-by-value
- При вызове по ссылке функции передается адрес аргумента. call-by-reference

Ссылочные параметры

Возврат ссылок

Создание ограниченного массива
Независимая ссылка — это просто еще одно название для переменных некоторого иного типа.

Перегрузка функций
Анахронизм в виде ключевого слова overload



#### 2022-04-19 : Страница 222 Глава 8: Функции, часть вторая: ссылки, перегрузка и использование аргументов по умолчанию Your Progress c++ 28.1013 %

2022-04-19 22:26:41 Page 222 / 790 Your Progress c++ 28.1013 %
2022-04-22 17:16:15 Глава 9: Еще о типах данных и операторах Page 234 / 790 Your Progress c++ 29.6203 %



### Спецификаторы классов памяти
C++ поддерживает пять спецификаторов классов памяти:
auto
extern

Спецификатор extern делает переменную известной для
модуля, но в действительности не создает ее.

register - в цп
static - в функции или скрипте 

Переменные типа static — это переменные "долговременного" хранения, т.е. они хранят
свои значения в пределах своей функции или файла. От глобальных они отличаются тем,
что за рамками своей функции или файла они неизвестны.

mutable


2022-04-22 18:01:40 Page 242 / 790 Your Progress c++ 30.6329 %


Перечисления

enum type_name { список_перечисления } список_переменных;
enum apple {Jonathan, Golden_Del, Red_Del, Winesap, Cortland,
McIntosh} red, yellow;

Ключевое слово typedef

typedef тип новое_имя;

typedef float balance;
balance over_due;

Поразрядные операторы


значение >> число_битов
А оператор сдвига влево используется так.
значение << число_битов



#### страница 265 отображене побитовых чисел disp_binary


Выражение1? Выражение2 : Выражение3;

Составные операторы присваивания

х = х - 100;
аналогична такой:
x -= 100;


var = (count=19, incr=10, count+1);
переменной count сначала присваивается число 19, переменной incr — число 10, а затем
к значению переменной count прибавляется единица

count = incr = index = 10;



Использование ключевого слова sizeof
Иногда полезно знать размер (в байтах) одного из типов данных. Поскольку размеры
встроенных С++-типов данных в разных вычислительных средах могут быть различными, а
знание размера переменной во всех ситуациях имеет важное значение, то для решения этой
проблемы в C++ включен оператор (действующий во время компиляции программы),
который используется в двух следующих форматах.


sizeof (type)
sizeof value



#### Динамическое распределение памяти с использованием операторов new и delete


Оператор new позволяет динамически выделить область памяти.
Язык C++ содержит два оператора, new и delete, которые выполняют функции по
выделению и освобождению памяти. Приводим их общий формат.
переменная-указатель = new тип_переменной;delete переменная-указатель;
Оператор delete освобождает ранее выделенную динамическую память.


Выделение памяти для массивов
С помощью оператора new можно выделять память и для массивов. Вот как выглядит
общий формат операции выделения памяти для одномерного массива:
переменная-указатель = new тип [размер];
Здесь элемент размер задает количество элементов в массиве.
Чтобы освободить память, выделенную для динамически созданного массива,
используйте такой формат оператора delete:
delete [] переменная-указатель;

Динамическое распределение памяти в языке С: функции malloc() и free()


malloc() предназначена для выделения памяти, а функция frее() — для ее освобождения


#### Глава 10: Структуры и объединения 2022-04-24 22:39:11 Page 278 / 790 Your Progress c++ 35.1899 %

В языке C++ определено несколько составных типов данных, т.е. типов, которые состоят
из двух или более элементов. С одним из составных 

Типы  — Массивом
	  — Структурами
	  — Объединениями
	  — Классом


Структура — это группа связанных переменных.
В C++ структура представляет собой коллекцию объединенных общим именем
переменных, которая обеспечивает удобное средство хранения родственных данных в одном
месте. Структуры — это совокупные типы данных, поскольку они состоят из нескольких
различных, но логически связанных переменных. По тем же причинам их иногда называют
составными или конгломератными типами данных.

```c++

struct inv_type {
char item[40]; // наименование товара
double cost; // стоимость
double retail; // розничная цена
int on_hand; // имеющееся в наличии количество
int lead_time; // число дней до пополнения запасов
};


struct имя_типа_структуры {
тип имя_элемента1;
тип имя_элемента2;
тип имя_элемента3;
.
.
.
тип имя_элементаN;
} структурные_переменные;
```

Доступ к членам структуры

inv_var.cost = 10.39;

strcpy(one.name, "Alpha");




Массивы структур
Структуры могут быть элементами массивов. И в самом деле, массивы структур
используются довольно часто. Чтобы объявить массив структур, необходимо сначала
определить структуру, а затем объявить массив элементов этого структурного типа.
Например, чтобы объявить 100-элементный массив структур типа inv_type (который
определен выше), достаточно записать следующее.



#### Глава 10: Структуры и объединения 2022-04-24 23:55:05 Page 285 / 790 Your Progress c++ 36.076 %


Передача структур функциям


-> Использование указателей на структуры и оператора "стрелка"


```c++

структуру, объявляем структурную переменную и указатель на структуру определенного
нами типа.
struct bal {
float balance;
char name[80];
}
person;
bal *p; // Объявляем указатель на структуру.
Тогда при выполнении инструкции
р = &person;
в указатель р будет помещен адрес структурной переменной person.
К членам структуры можно получить доступ с помощью указателя на эту структуру. Но в
этом случае используется не оператор "точка", а оператор "->". Например, при выполнении
этой инструкции мы получаем доступ к полю balance через указатель р:
p->balance
Оператор "->" называется оператором "стрелка". Он образуется с использованием
знаков "минус" и "больше".


```

Узелок на память. Чтобы получить доступ к членам структуры, используйте
оператор "точка". Чтобы получить доступ к членам структуры с помощью указателя,
используйте оператор "стрелка".


Ссылки на структуры


#### Глава 11: Введение в классы 2022-04-25 22:41:40 Page 320 / 790 Your Progress c++ 40.5063 %


Оператор разрешения области видимости квалифицирует имя члена вместе с именем
его класса.
Оператор "::" называется оператором разрешения области видимости. По сути, он
сообщает компилятору, что данная версия функции qput() принадлежит классу queue.
Другими словами, оператор "::" заявляет о том, что функция qput() находится в области
видимости класса queue. Различные классы могут использовать одинаковые имена функций.
Компилятор же определит, к какому классу принадлежит функция, с помощью оператора
разрешения области видимости и имени класса.
Функции-члены можно вызывать только относительно заданного объекта. Чтобы
вызвать функцию-член из части программы, которая находится вне класса, необходимо
использовать имя объекта и оператор "точка". Например, при выполнении этого кода будет
вызвана функция init() для объекта ob1.


```c++
class имя_класса {
		закрытые данные и функции
		public:
		открытые данные и функции
	} список_объектов;

```

Доступ к членам класса


Конструкторы и деструкторы

#### 2022-04-27 21:49:18 Page 330 / 790 Your Progress c++ 41.7722 %

Конструктор — это функция, которая вызывается при создании объекта.

```c++

// Определение класса queue.
class queue {

	int q[100];
	int sloc, rloc;

	public:

	queue(); // конструктор
	
	~queue(); // деструктор

	void qput(int i);
	int qget();
};


// Определение конструктора.
queue::queue()
{
	sloc = rloc = 0;
	cout << "Очередь инициализирована.\n";
}

// Определение деструктора.
queue::~queue()
{
	cout << "Очередь разрушена.\n";
}
```


Деструктор — это функция, которая вызывается при разрушении объекта.


queue а = queue (101);
В этом объявлении создается очередь с именем a, которой передается значение
(идентификационный номер) 101. Но эта форма (в таком контексте) используется редко,
поскольку второй способ имеет более короткую запись и удобнее для использования. Во
втором способе аргумент должен следовать за именем объекта и заключаться в круглые
скобки. Например, следующая инструкция эквивалентна предыдущему объявлению,
queue а (101);
Это самый распространенный способ объявления параметризованных объектов.
Опираясь на этот метод, приведем общий формат передачи аргументов конструкторам.
тип_класса имя_переменной(список_аргументов);
Здесь элемент список_аргументов представляет собой список разделенных запятыми
аргументов, передаваемых конструктору.


Классы и структуры — родственные типы

#### 2022-04-27 22:48:17 Page 342 / 790 Your Progress c++ 43.2911 %

#### Глава 12: О классах подробнее 2022-04-28 22:44:32 Page 361 / 790 Your Progress c++ 45.6962 %

Функции-"друзья"

Перегрузка конструкторов 

#### 2022-04-28 22:53:20 Page 369 / 790 Your Progress c++ 46.7089 %



